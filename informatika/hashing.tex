\subsection{Hashing}

Vynaliezavosti sa medze nekladú a tak si Fourierova transformácia
našla svoju cestu aj do bezpečnosti a vytvárania hashovacích funkcií.
Idea je tu už pomerne dávno, ako ukazujú články od C.P. Schnorra.
Navrhol postupne 2 hashovacie funkcie založené na Fourierovej
transformácii. Žiaľ, ako sa ukázalo, jeho prístup nebol dostatočný.
Prvá funkcia a nejskôr i jej nová varianta ktorú možno nájsť v
\cite{schnorr} podľahli kryptoanalýze a
ukázalo sa, že nie je až taký veľký problém nájsť kolízie
\cite{ffthash_collisions}.
V roku 2006 sa však objavil článok od pánov 
Vadim Lyubashevsky,
Daniele Micciancio,
Chris Peikert,
Alon Rosen ukazujúci nový prístup k hashovanie pomocou Fourierovej
transformácie. Tento postup si teraz popíšeme

\begin{itemize}
    \item Vstup programu budeme reprezentovať ako maticu $x_{i,j}$
    rozmerov $m\cross n$, kde $n=2^k$ je tazkvaný "bezpečnostný
    parameter" a $m$ je malá konštanta (napr. $m=8$) a navyše budeme
    uvažovať podmienku $0\le x_{i,j}\le 4 \text{alebo} 8, x_{i,j}\in Z$.
    Posledná podmienka je veľmi kritická pre dôkazy o bezpečnosti a
    bezkolíznosti hashovacej funckie
    \item Nájdeme prvočíslo tvaru $p=2tn+1$. Odteraz budeme všetky
    výpočty robiť modulo $p$.
    \item Zvolíme si konštantu $\omega$, ktorej rád v $Z_p$ je $2n$ 
    a spravíme Fourierovu
    transformáciu po riadkoch nasledovne
    \begin{equation}
     (y_{i,1}, y_{i,2}, \dots, y_{i,n}) = FFT(
     \omega^0 x_{i,1}, \omega^1 x_{i,2}, \dots, \omega^{n-1}
     x_{i,n})
     \end{equation}
     Táto operácia je ľahko invertovateľná a používame ju na
     spôsobenie difúzie
    \item
     Posledným krokom je zvolenie náhodnej matice $a$ a vypočítanie
     lineárnej kombinácie každého stĺpca, teda
      $z_j = a_{1,j} y_{1,j} + \dots + a_{m,j} + y_{m,j}$.
    \item
     Výsledok je vektor $(z_1, \dots, z_n)$.
\end{itemize}
Pozeraním na posledný krok algoritmu, nájsť riešenie pre 
 $y_{i,g}$ nie na náročné ak poznáme $z$. Skôr naopak, riešení je veľa a
 dajú sa ľahko nájsť.
 To, čo robí tento algoritmus pomerne bezpečným (a to, čo chýbalo
 Shnorrovým dvom funkciám) je obmedzenie na vstupe.
 Hodnoty $y_{i,j}$ totiž musia vzniknúť z malých hodnôt $x_{i,j}$.
 Toto obmedzenie je prudko nelineárne a 
 ako sa ukazuje, je dostatočné na to, aby sa dali
 dokázať isté kryptografické vlastnosti funkcie.
 Viac o tomto prístupe k hashovaniu a taktiež dôkaz o bezpečnosti
 funkcie môže láskavý čitateľ nájsť v \cite{fft-hash} a
 \cite{fft-swifft}.
